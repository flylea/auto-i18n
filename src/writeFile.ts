import fs from "node:fs";
import path from "node:path";
import chalk from "chalk";

export interface I18nConfig {
  entryDirs: string[];
  extensions: string[];
  output: "ts" | "js" | "json";
  outputDir: string;
  withFileComment: boolean;      // 文件头注释
  withKeyFileComment: boolean;   // key → 文件路径注释
  i18nFns: string[];
  supportChineseKey: boolean;
  languages: string[];
}

/**
 * 扁平 key => 嵌套对象
 * user.avatar => { user: { avatar: ... } }
 */
function flatToNested(flat: Record<string, string>) {
  const nested: Record<string, any> = {};

  for (const [fullKey, value] of Object.entries(flat)) {
    const segments = fullKey.split(".");
    let cur = nested;

    segments.forEach((seg, idx) => {
      if (idx === segments.length - 1) {
        cur[seg] = value;
      } else {
        cur[seg] ||= {};
        cur = cur[seg];
      }
    });
  }

  return nested;
}

/**
 * 构建「顶层 key -> 文件路径集合」映射
 * user.avatar -> user
 */
function buildTopLevelFileMap(
  keyFileMap: Map<string, Set<string>>
): Map<string, Set<string>> {
  const result = new Map<string, Set<string>>();

  for (const [fullKey, files] of keyFileMap.entries()) {
    const topKey = fullKey.split(".")[0];

    if (!result.has(topKey)) {
      result.set(topKey, new Set());
    }

    files.forEach((f) => result.get(topKey)!.add(f));
  }

  return result;
}

/**
 * 递归生成对象字符串
 * - 只在顶层输出 key → 文件路径注释
 * - 是否输出完全由配置控制
 */
function stringifyObject(
  obj: Record<string, any>,
  options: {
    indent: number;
    level: number;
    isJSON: boolean;
    keyFileMap?: Map<string, Set<string>>;
    supportChineseKey: boolean;
    withKeyFileComment: boolean;
  }
): string {
  const {
    indent,
    level,
    isJSON,
    keyFileMap,
    supportChineseKey,
    withKeyFileComment,
  } = options;

  const nextPad = " ".repeat(indent * (level + 1));
  const lines: string[] = [];
  const entries = Object.entries(obj);

  entries.forEach(([key, value], index) => {
    const isTopLevel = level === 0;

    // 顶层 key → 来源文件注释
    if (
      !isJSON &&
      isTopLevel &&
      withKeyFileComment &&
      keyFileMap
    ) {
      const files = keyFileMap.get(key);
      if (files && files.size > 0) {
        lines.push("");
        files.forEach((file) => {
          lines.push(`${nextPad}// ${file}`);
        });
      }
    }

    const keyStr =
      supportChineseKey && /[\u4e00-\u9fa5]/.test(key)
        ? `'${key}'`
        : key;

    if (typeof value === "object" && value !== null) {
      lines.push(`${nextPad}${keyStr}: {`);
      lines.push(
        stringifyObject(value, {
          ...options,
          level: level + 1,
        })
      );
      lines.push(
        `${nextPad}}${index < entries.length - 1 ? "," : ""}`
      );
    } else {
      const val =
        typeof value === "string"
          ? `'${value.replace(/'/g, "\\'")}'`
          : JSON.stringify(value);

      lines.push(
        `${nextPad}${keyStr}: ${val}${
          index < entries.length - 1 ? "," : ""
        }`
      );
    }
  });

  return lines.join("\n");
}

/**
 * 写入 i18n 文件（最终入口）
 */
export async function writeI18nFiles(
  translateResult: Record<string, Record<string, string>>,
  keyFileMap: Map<string, Set<string>>,
  config: I18nConfig,
  logger: any
) {
  const outputDir = path.resolve(process.cwd(), config.outputDir);
  fs.mkdirSync(outputDir, { recursive: true });

  const isJSON = config.output === "json";
  const topLevelFileMap = buildTopLevelFileMap(keyFileMap);

  for (const lang of config.languages) {
    const flat: Record<string, string> = {};

    Object.entries(translateResult).forEach(([key, map]) => {
      if (map[lang]) flat[key] = map[lang];
    });

    const nested = flatToNested(flat);
    const lines: string[] = [];

    // 文件头注释（严格受控）
    if (config.withFileComment && !isJSON) {
      lines.push(
        "/**",
        ` * I18n locale file: ${lang}`,
        ` * Auto-generated by auto-i18n`,
        ` * Generated at: ${new Date().toLocaleString()}`,
        " */"
      );
    }

    if (isJSON) {
      lines.push(JSON.stringify(nested, null, 2));
    } else {
      lines.push("export default {");
      lines.push(
        stringifyObject(nested, {
          indent: 2,
          level: 0,
          isJSON,
          keyFileMap: topLevelFileMap,
          supportChineseKey: config.supportChineseKey,
          withKeyFileComment: config.withKeyFileComment,
        })
      );
      lines.push("};");
    }

    const filePath = path.join(outputDir, `${lang}.${config.output}`);
    fs.writeFileSync(filePath, lines.join("\n"), "utf-8");

    logger.success(
      `Generated ${chalk.yellow(`${lang}.${config.output}`)}`
    );
  }
}
